


* Abstraction etc


* Technology neutral

i.e. wind and solar do no appear in main libraries




* Assume indexed lists are typesafe

i.e. no type checking on load.p_set_series

* networkx

Nodes and edges are the electrically reduced version of buses and branches.


* Separate data from code

The versioned code libraries should not contain ANY data at all (apart from perhaps usage examples and unit testing).

Scripts that use the libraries can link data together.

Data should be managed completely separately (preferably in databases)


* Use objects where possible

i.e. avoid dictionaries called "data"

* Avoid generating data dynamically if possible

e.g. add edge, etc.

better to version the data models

* store data in a database?

also power stations characteristics, etc.

fuel costs and CO2 emissions per MWhthermal, etc.


* Use an object-oriented GUI as far as possible - no free-hanging functions

E.g.

graph.do_something()

rather than

def do_something(graph)


not sure about this, perhaps a matter of taste...
* Optimization framework

At the moment the optimization is mostly hard-coded to gurobi

Would be good to use more general framework like pyomo so we can try other solvers at some point



* Default units

kV, Ohm, MW, A


* TODO


** move guidelines.org to doc/

** more detailed regression testing

Use classes to do multiple tests with same set-up

** Yearly import/export balances for zones
Need to define countries etc.

class Zone



** Python 3 improve

use six for itervalues()/values()

** CIM converter

look at Richard Lincoln's PyCIM

** ConstantSeries???

i.e. have some way of setting constant time series to save memory

** Naming considerations for components and attributes

*** SubNetwork -> ConnectedNetwork

*** DONE classes -> components

network is no good - confuses with Network class / network object / networkx

*** s_nom versus p_nom for lines/branches


** take v_mag_set from generators?

instead of bus? like pypower

** look at pandas for storing object methods in different files

want different files, but still have tab completion and ? and ?? magic

over-ride __dir__???


** newton-raphson for DC networks

i.e. solve P_i = \sum_j V_i Y_ij V_j

where everything is real

Can set either P or V at bus

Need one slack

** make p_set per unit?


** Better as sqlalchemy?????

Advantages of database:

i) better scaling with size

ii) easier, better querying

iii) persistence

iv) can swop out database for Netzbetreiber

v) Sharing data between people editing concurrently

vi) Transactions (e.g. bank account transfer that fails or succeeds always at both ends)

vii) For relations between tables



** Series impedances

** ratio and phase shift for trafos

** catch no gens in sub_network?


** beware nx.MultiGraph reordering of edges!

Orders them according to collections of edges between same nodes NOT
the order in which you read them in.

** Kill inheritance?

It doesn't serve any good purpose and just serves to confuse.

e.g. storage_unit inherits generator's efficiency, which doesn't make any sense.


need to watch out for isinstance(Branch)


** Do not define empty timeseries contents until called, e.g.

network.generators_df.p = pd.DataFrame(index = network.snapshots)

network.generators_df.p.loc[1,"AT"] = 45.

- this will define a new column "AT" and add NaNs in other entries.

(at least for calculated quantities - p_set etc. should be defined)

give default if name not in col????

** fix angle bound limits!!!!!

Currently set to None; should allow limits on angle *differences* not the actual angles

** component.__init__

should just do network and name, since have two interfaces for adding components and their attributes:

network.add()

network.import_from_df()




** Compare with oemof optimisation

~/fias/oemof/oemof_base/oemof/solph/optimization_model.py

more abstract and sophisticated than pypsa somehow


Also snaffles dual variables in post-processing


from oemof.solph.optimization_model import OptimizationModel as OM

class OptimizationModel(po.ConcreteModel)


** Property-based dynamically-generated DataFrames do NOT include the time-dependent quantities!!

** Underscore dynamically-generated DataFrames?

Since they are NOT linked to original data for updating, and don't contain time-dependent quantities.
** Fix examples after pandification
** Check branch.bus0 and branch.bus1 in network.buses

Similarly for generator.source

try:
network.buses.loc[branch.bus0]
except:
missing!

** OPF DC output to v_mag not v_ang

Also make v_mag per unit NOT kV


** replace descriptors with __get__ and __set__ on objects

Can then use obj.attr for attr which are dynamically added to DataFrame

def __set__(attr,val):

try:
   val = attr_type(val)
except:
  oops!

if attr in df.columns:
df.loc[self.name,attr] = val

else:

#return to normal object set
setattr(self,attr,val)


Store attributes in

class Branch:

    static_attributes = {{}}

    series_attributes = {{}}

* DONE


** newton-raphson for AC


~/.virtualenvs/tom/lib/python2.7/site-packages/pypower/newtonpf.py

~/.virtualenvs/tom/lib/python2.7/site-packages/pypower/dSbus_dV.py


** Documentation in sphinx/rst

cf. oemof

started org-mode docu in doc/ - can be based on this documentation


** DONE read out dual variables in opf results

Done for the locational marginal price - not clear whether other
constraints are necessary (e.g. line upper/lower).

Note that shadow price at buses also include capacity extensions when
capacity is being mit-optimised - only really useful when capacity is
fixed and only dispatch is being optimised.

** DONE Catch optimisation status gracefully

i.e. when it fails or is infeasible, catch the status and inform the user


** DONE non-linear pf

See

~/.virtualenvs/tom/lib/python2.7/site-packages/pypower/makeYbus.py

~/.virtualenvs/tom/lib/python2.7/site-packages/pypower/runpf.py

~/.virtualenvs/tom/lib/python2.7/site-packages/pypower/newtonpf.py


I = YV

I_bus_inj = \sum I_branch_inj = Y V_bus

Branch to = Y_t V_bus

Branch from = Y_f V_bus



** improve pypower import

see ~/fias-shared/playground/nl_pf/fix_pypower_import.py


In pypower branch x,r are per unit of nominal voltage and of baseMVA.

So adjusted all r,x to give correct angle behaviour (which agrees
exactly, up to translation of slack angle).


In pypower bus shunt g,b are per unit of nominal voltage and 1 MVA,
i.e. the values gives the power in MVA for 1.0 per unit voltage.



** check results per unit behaviour

e.g. per unit power



** Voltage-dependent and ZIP loads

see PyPower and PSAT

done as shunt impedances

** DONE Shunt impedances


** DONE Capacity extension for controllable branches

** DONE Storage model


See David's branch in flexibility, regions.classes

benchmarkopt/optimization.py


Should include:

Settable SoC, Soc min/max, separate efficiencies

running loss


** DONE regression testing

with nose?

see Jonas email of 151109

no, use py.test


** DONE isinstance

also applies for inheritance? yes  - if the class A inherits from B, isinstance true for A and B



** DONE Improve dataframe readin

For lines csv:

concat with network.lines

check index is still unique

fill in non-present columns with defaults

set to network.lines



Beware adding attributes which should be series!!


** DONE Go back to simple naming?

When creating DataFrames/Series combining components (e.g. branches), which should only happen internally, could rename them there, or index by object instead of name to avoid naming collisions

BUT want branch.name for index set in opf....

Compromise: have obj.uid = Class.name + " " + obj.name?




** DONE Include bus names in the dataframe of branches, loads and generators

** DONE OrderedGraph of branches will not necessarily have unique names!!!!

Add component class name to start of name

What's also an issue is that the inherited descriptors are also shared between the objects, so that the descriptor actually belongs to the parent class.

so that Branch.s_nom was in fact sharing components for all transport_links, lines, trafos etc.


Better solution: hierarchical pandas index, so built

subnetwork._branches

with index (Line, 0),.... (Transormer,0),.....



** DONE Allow graphs with multiple edges between same nodes

i.e. inherit from networkx.MultiGraph


** DONE catch load flow edge cases

<=1 line



** DONE Pandas backend for attributes

replace
            self.values[obj] = float(val)

with a pandas.DataFrame/Series for each network


get

self.values[network][obj.name]




** DONE Flow as Expression

build flows based on PTDF or angles

then use for nodal imbalance AND for flow limitation


** DONE think about storing tables for each component type

class Generators:
    name = ...
    p_set = DataFrame


network.generators.name = Series

network.generators[name] -> Generator object

network.generators.p = DataFrame (columns: gen_name, index: times)

generator.p = network.generators.p[gen.name]



Issue: generator.p_max_pu NOT needed for flexible generators

Need separate class e.g. VariableGenerator??? better than having type = .... and then different used methods

*** Better:

network.generators.p_max or Generators["p_max"] returns a series

Generators.p or Generators["p"] returns a DataFrame

Generator.df returns the df of


for gen in network.generators.obj:
   print gen


for gen_name in network.generators.index:
   print gen_name

for gen_name in network.generators.index:
   for dt in network.snapshots:
       print network.generators.p[gen][dt]



network.generators = pd.DataFrame(columns= ...., dtypes .....,index = gen_names)  #only contains time constant parts

network.generators["obj"]

network.generators.p_set = pd.DataFrame(columns=generator.names,index=network.snapshots)

netwrok.generators.p_set.ix[dt,gen_name]





*** DONE allow nan in Float

e.g. for p_nom_max

*** DONE create Boolean and Int descriptors

*** load.bus, bus.loads, generator.source
*** DONE first step: semi-pandify in e.g. network.generators_df, to which descriptors point

*** fix remove(obj)

DataFrame.drop(labels, axis=0, level=None, inplace=False, errors='raise')

df.drop(["i0","i3"]) will remove rows by index

df.drop(["n0","n3"], axis=1) will remove columns by name


*** import_dataframe directly to dataframe

and allow non-standard columns

*** rewrite pf and opf

network.generators.keys -> network.generators.index

network.generators.values -> network.generators["obj"]

attrfilter -> can use dataframe directly

sub_network.branches.itervalues() -> network.lines.loc[sub_network.lines] + network.transformers[sub_network.transformers]


** DONE linear pf/opf for DC meshed

How to deal with slack nodes and power balance within DC network for pf if there are no generators?


Choose slack bus as first/last DC bus with a converter/generator and then set the converter on the bus.

*** DONE linear pf

** DONE slack buses versus slack generators

Can have one bus with several PQ or PV generators and one slack generator - depends on generator, not on bus

ALSO: don't want to choose a slack bus where there is no generator


Cases:

Choose the slack bus by the first generator set as a slack; otherwise
choose the first generator in the sub-network.

i) If there is a slack generator on the bus, it is a slack bus

ii) If there is a PV generator on a non-slack bus, it is a PV bus; First PV generator sets the voltage

iii) Otherwise it is a PQ bus


Need to also fix pypower importer/exporter



*** Does PyPower allow for more than one generator per bus???

Yes. If there is more than one generator on a PV bus (type 2), then the Q is divided equally between the generators.

If there is more than one generator on a reference bus (type 3), then the Q is divided equally and the spare P is sent to the first generator.

see pfsoln.py




** DONE Make a complicated example with meshed AC-DC and some sub networks with 1 or 2 nodes.

** DONE Time weighting

network.snapshots

network.snapshot_weightings  - e.g. n hours each snapshot represents

** DONE CO2 constraint

class Source

** DONE Sort nexus efficiency CO2/MWht and CO2/MWhe

source.co2_emissions is tCO2e / MWht

gen.efficiency is MWhe/MWht

so emissions per MWhe are:

gen.source.co2_emissions / gen.efficiency   =   tCO2e / MWht  * (MWht/MWhe) = tCO2 / MWhe


** DONE do remove object


** DONE CSV file format

follow minpower with separate csv for each object type, i.e.

directory

generator.csv

bus.csv

lines.csv

generator-p_set.csv  - time-dependent set point


** DONE ensure object names are unique

can also check with pandas.index.unique

** DONE Pypower format converter
